# 使用指南与最佳实践

## 目录

1. [快速开始](#1-快速开始)
2. [配置优化](#2-配置优化)
3. [性能调优](#3-性能调优)
4. [调试技巧](#4-调试技巧)
5. [常见问题](#5-常见问题)
6. [最佳实践](#6-最佳实践)

---

## 1. 快速开始

### 1.1 基本路径请求

```cpp
// 1. 获取路径管理器实例
IPathManager* pathManager = pathManager;

// 2. 发起路径请求
unsigned int pathID = pathManager->RequestPath(
    unit,                    // 请求单位
    unit->moveDef,          // 移动定义
    unit->pos,              // 起始位置
    targetPos,              // 目标位置  
    goalRadius,             // 目标半径
    true,                   // 同步标志
    false                   // 非立即结果
);

// 3. 检查路径状态
if (pathID != 0) {
    // 路径请求成功提交
    unit->pathID = pathID;
} else {
    // 路径请求失败
    HandlePathRequestFailure(unit);
}
```

### 1.2 获取路径点

```cpp
void UpdateUnitMovement(CUnit* unit) {
    if (unit->pathID == 0) return;
    
    // 获取下一个路径点
    float3 nextWaypoint = pathManager->NextWayPoint(
        unit,                   // 单位
        unit->pathID,          // 路径ID
        0,                     // 重试次数
        unit->pos,             // 当前位置
        unit->radius,          // 单位半径
        true                   // 同步标志
    );
    
    // 检查路径有效性
    if (nextWaypoint.x != -1.0f) {
        // 有效路径点，更新单位目标
        unit->moveType->StartMoving(nextWaypoint, unit->maxSpeed);
    } else {
        // 路径结束或无效
        pathManager->DeletePath(unit->pathID);
        unit->pathID = 0;
    }
}
```

### 1.3 清理路径

```cpp
// 主动删除不再需要的路径
void CleanupUnitPath(CUnit* unit) {
    if (unit->pathID != 0) {
        pathManager->DeletePath(unit->pathID, false); // 非强制删除
        unit->pathID = 0;
    }
}

// 单位销毁时强制清理
void DestroyUnit(CUnit* unit) {
    if (unit->pathID != 0) {
        pathManager->DeletePath(unit->pathID, true);  // 强制删除
        unit->pathID = 0;
    }
    
    delete unit;
}
```

## 2. 配置优化

### 2.1 核心参数配置

```cpp
// PathConstants.h中的关键参数
namespace PathConstants {
    // 搜索距离阈值 - 影响分层选择
    constexpr float MAXRES_SEARCH_DISTANCE = 50.0f;   // 高精度阈值
    constexpr float MEDRES_SEARCH_DISTANCE = 200.0f;  // 中精度阈值
    
    // 搜索限制 - 控制性能
    constexpr unsigned int MAX_SEARCHED_NODES = 65536;      // 最大搜索节点
    constexpr unsigned int SQUARES_TO_UPDATE = 8000;        // 每帧更新限制
    
    // 块大小配置 - 影响精度和性能
    constexpr unsigned int MEDRES_PE_BLOCKSIZE = 16;   // 中精度块大小
    constexpr unsigned int LOWRES_PE_BLOCKSIZE = 32;   // 低精度块大小
    
    // 路径节点间距 - 影响路径密度
    constexpr unsigned int PATH_NODE_SPACING = 2;      // 路径点间距
}
```

### 2.2 地图特定优化

```cpp
// 根据地图大小调整参数
void ConfigureForMapSize(int mapWidth, int mapHeight) {
    const int mapArea = mapWidth * mapHeight;
    
    if (mapArea <= 512 * 512) {
        // 小地图配置
        PathConstants::MAX_SEARCHED_NODES = 32768;
        PathConstants::SQUARES_TO_UPDATE = 4000;
        PathConstants::MAXRES_SEARCH_DISTANCE = 80.0f;
    } else if (mapArea <= 1024 * 1024) {
        // 中等地图配置  
        PathConstants::MAX_SEARCHED_NODES = 65536;
        PathConstants::SQUARES_TO_UPDATE = 8000;
        PathConstants::MAXRES_SEARCH_DISTANCE = 50.0f;
    } else {
        // 大地图配置
        PathConstants::MAX_SEARCHED_NODES = 32768;  // 降低以保持性能
        PathConstants::SQUARES_TO_UPDATE = 12000;   // 增加更新量
        PathConstants::MAXRES_SEARCH_DISTANCE = 30.0f; // 降低高精度阈值
    }
}
```

### 2.3 移动类型优化

```cpp
// 为不同移动类型定制参数
void OptimizeForMoveType(const MoveDef* moveDef) {
    if (moveDef->moveFamily == MoveDef::Tank) {
        // 坦克类：需要精确路径
        moveDef->pathOptimization.preferHighRes = true;
        moveDef->pathOptimization.pathSmoothingFactor = 0.3f;
        
    } else if (moveDef->moveFamily == MoveDef::Ship) {
        // 船只类：可以接受粗糙路径
        moveDef->pathOptimization.preferHighRes = false;
        moveDef->pathOptimization.maxSearchDistance = 300.0f;
        
    } else if (moveDef->moveFamily == MoveDef::Hover) {
        // 悬浮类：平衡精度和性能
        moveDef->pathOptimization.adaptiveResolution = true;
        moveDef->pathOptimization.terrainAvoidance = 0.5f;
    }
}
```

## 3. 性能调优

### 3.1 线程配置

```cpp
// 根据CPU核心数配置线程
void ConfigureThreading() {
    const int numCores = std::thread::hardware_concurrency();
    
    if (numCores >= 8) {
        // 多核系统：充分并行
        pathFinderGroups = numCores;
        pathingStateWorkloadRatio = 0.7f;
        
    } else if (numCores >= 4) {
        // 四核系统：平衡配置
        pathFinderGroups = 4;
        pathingStateWorkloadRatio = 0.8f;
        
    } else {
        // 双核系统：保守配置
        pathFinderGroups = 2;  
        pathingStateWorkloadRatio = 0.9f;
    }
    
    LOG("HAPFS configured for %d threads", pathFinderGroups);
}
```

### 3.2 内存优化

```cpp
// 内存使用监控和优化
class MemoryOptimizer {
    size_t maxMemoryUsage = 512 * 1024 * 1024; // 512MB限制
    
public:
    void OptimizeMemoryUsage() {
        size_t currentUsage = GetCurrentMemoryUsage();
        
        if (currentUsage > maxMemoryUsage * 0.9f) {
            // 内存使用率过高，采取优化措施
            
            // 1. 减少缓存大小
            pathManager->ReduceCacheSize(0.5f);
            
            // 2. 降低搜索节点限制
            PathConstants::MAX_SEARCHED_NODES *= 0.8f;
            
            // 3. 增加缓存清理频率
            pathManager->SetCacheCleanupInterval(30); // 每30帧清理一次
            
            LOG_L(L_WARNING, "HAPFS memory optimization triggered: %zuMB used", 
                  currentUsage / (1024*1024));
        }
    }
    
private:
    size_t GetCurrentMemoryUsage() const {
        size_t usage = 0;
        usage += pathManager->GetMemoryUsage();
        usage += pathHeatMap->GetMemoryUsage();  
        usage += pathFlowMap->GetMemoryUsage();
        return usage;
    }
};
```

### 3.3 动态负载均衡

```cpp
void CPathManager::BalanceWorkload() {
    // 获取当前队列状态
    int2 queueSizes = GetNumQueuedUpdates();
    
    // 计算负载比率
    float medResLoad = float(queueSizes.x) / 1000.0f;  // 中精度负载
    float lowResLoad = float(queueSizes.y) / 2000.0f;  // 低精度负载
    
    // 动态调整工作分配
    if (medResLoad > 1.5f) {
        // 中精度队列过载
        pathStateWorkloadRatio = std::min(0.9f, pathStateWorkloadRatio + 0.1f);
        highPriorityResPS = true;
        
    } else if (lowResLoad > 1.5f) {
        // 低精度队列过载
        pathStateWorkloadRatio = std::max(0.5f, pathStateWorkloadRatio - 0.1f);
        highPriorityResPS = false;
        
    } else {
        // 恢复正常负载
        pathStateWorkloadRatio = 0.8f;
        highPriorityResPS = false;
    }
}
```

## 4. 调试技巧

### 4.1 路径可视化

```cpp
// 启用路径调试可视化
void EnablePathDebugVisualization() {
    #ifdef DEBUG_PATHFINDING
    pathManager->SetDebugMode(true);
    pathManager->SetVisualizationLevel(DEBUG_LEVEL_DETAILED);
    
    // 可视化选项
    pathManager->ShowSearchedNodes(true);      // 显示搜索节点
    pathManager->ShowPathSmoothing(true);      // 显示路径平滑
    pathManager->ShowHeatMap(true);            // 显示热力图
    pathManager->ShowFlowField(true);          // 显示流场
    #endif
}

// 单个路径的调试信息
void DebugPath(unsigned int pathID) {
    MultiPath path = pathManager->GetMultiPathMT(pathID);
    
    LOG("Path %u Debug Info:", pathID);
    LOG("  Search Result: %s", PathResultToString(path.searchResult));
    LOG("  Low Res Path: %zu points", path.lowResPath.path.size());
    LOG("  Med Res Path: %zu points", path.medResPath.path.size());  
    LOG("  Max Res Path: %zu points", path.maxResPath.path.size());
    LOG("  Path Cost: %.2f", path.maxResPath.pathCost);
    LOG("  Search Time: %.2fms", path.searchTime);
    
    // 输出路径点详情
    for (size_t i = 0; i < path.maxResPath.path.size(); ++i) {
        const float3& point = path.maxResPath.path[i];
        LOG("    Point %zu: (%.1f, %.1f, %.1f)", i, point.x, point.y, point.z);
    }
}
```

### 4.2 性能分析

```cpp
// 性能监控和分析
class PathfindingProfiler {
    struct ProfileData {
        std::chrono::high_resolution_clock::time_point startTime;
        float totalTime = 0.0f;
        int callCount = 0;
        
        void Start() {
            startTime = std::chrono::high_resolution_clock::now();
        }
        
        void End() {
            auto endTime = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
                endTime - startTime);
            
            totalTime += duration.count() / 1000.0f; // 转换为毫秒
            callCount++;
        }
        
        float GetAverageTime() const {
            return (callCount > 0) ? (totalTime / callCount) : 0.0f;
        }
    };
    
    ProfileData pathFinderProfile;
    ProfileData pathEstimatorProfile;  
    ProfileData pathManagerProfile;
    
public:
    void LogPerformanceReport() {
        LOG("HAPFS Performance Report:");
        LOG("  PathFinder: %.2fms avg (%d calls)", 
            pathFinderProfile.GetAverageTime(), pathFinderProfile.callCount);
        LOG("  PathEstimator: %.2fms avg (%d calls)",
            pathEstimatorProfile.GetAverageTime(), pathEstimatorProfile.callCount);
        LOG("  PathManager: %.2fms avg (%d calls)",
            pathManagerProfile.GetAverageTime(), pathManagerProfile.callCount);
    }
};
```

### 4.3 错误诊断

```cpp
// 路径失败原因分析
void DiagnosePathFailure(unsigned int pathID) {
    MultiPath path = pathManager->GetMultiPathMT(pathID);
    
    switch (path.searchResult) {
        case IPath::Error:
            LOG_L(L_ERROR, "Path %u failed: Generic error", pathID);
            CheckMapBounds(path);
            CheckMoveDef(path);
            break;
            
        case IPath::GoalOutOfRange:
            LOG_L(L_WARNING, "Path %u failed: Goal out of range", pathID);
            CheckGoalReachability(path);
            break;
            
        case IPath::CrappyPath:
            LOG_L(L_INFO, "Path %u: Low quality path generated", pathID);
            SuggestPathImprovements(path);
            break;
    }
}

void CheckGoalReachability(const MultiPath& path) {
    // 检查目标是否被建筑物阻挡
    if (IsPositionBlocked(path.peDef.wsGoalPos)) {
        LOG_L(L_WARNING, "Goal position is blocked by structures");
    }
    
    // 检查移动类型是否能到达目标地形
    if (!CanMoveTypeReachTerrain(path.moveDef, path.peDef.wsGoalPos)) {
        LOG_L(L_WARNING, "Move type cannot reach target terrain");
    }
}
```

## 5. 常见问题

### 5.1 路径质量问题

**问题**: 单位走锯齿路径或卡在障碍物上

```cpp
// 解决方案：调整路径平滑参数
void FixPathSmoothing() {
    // 增加路径平滑强度
    PathConstants::PATH_SMOOTHING_FACTOR = 0.5f;
    
    // 降低路径节点密度
    PathConstants::PATH_NODE_SPACING = 3;
    
    // 启用高级平滑算法
    pathManager->EnableAdvancedSmoothing(true);
}
```

**问题**: 单位选择非最优路径

```cpp
// 解决方案：调整启发式函数权重
void ImprovePathOptimality() {
    // 降低启发式函数权重，更接近Dijkstra
    pathManager->SetHeuristicWeight(0.8f);
    
    // 增加搜索节点限制，允许更广泛搜索
    PathConstants::MAX_SEARCHED_NODES = 131072;
    
    // 启用双向搜索
    pathManager->EnableBidirectionalSearch(true);
}
```

### 5.2 性能问题

**问题**: 路径搜索导致帧率下降

```cpp
// 解决方案：限制搜索开销
void LimitPathfindingCost() {
    // 降低每帧最大搜索节点数
    PathConstants::MAX_SEARCHED_NODES_PER_FRAME = 8192;
    
    // 增加路径复用率
    pathManager->SetPathSharingRadius(32.0f);
    
    // 启用异步路径搜索
    pathManager->EnableAsyncPathfinding(true);
}
```

**问题**: 内存使用过高

```cpp
// 解决方案：优化内存配置
void OptimizeMemoryUsage() {
    // 减少缓存大小
    pathManager->SetMaxCacheSize(5000);
    
    // 启用压缩存储
    pathManager->EnablePathCompression(true);
    
    // 更频繁地清理缓存
    pathManager->SetCacheCleanupFrequency(60); // 每60帧清理
}
```

### 5.3 同步问题

**问题**: 多人游戏中路径不同步

```cpp
// 解决方案：确保确定性
void EnsurePathfindingDeterminism() {
    // 使用固定的随机种子
    pathManager->SetRandomSeed(gameStartTime);
    
    // 禁用非确定性优化
    pathManager->DisableNonDeterministicOptimizations();
    
    // 启用同步检查
    pathManager->EnableSyncChecks(true);
    
    // 使用确定性浮点运算
    pathManager->UseFixedPointMath(true);
}
```

## 6. 最佳实践

### 6.1 路径请求策略

```cpp
// 避免频繁的路径请求
class SmartPathRequester {
    float lastRequestTime = 0.0f;
    float minRequestInterval = 0.5f; // 最小请求间隔
    
public:
    bool ShouldRequestNewPath(const CUnit* unit, const float3& newGoal) {
        // 1. 时间间隔检查
        if (gs->frameNum - lastRequestTime < minRequestInterval * GAME_SPEED) {
            return false;
        }
        
        // 2. 距离阈值检查
        if (unit->currentGoal.distance2D(newGoal) < unit->radius * 2.0f) {
            return false; // 目标变化不大
        }
        
        // 3. 路径有效性检查
        if (unit->pathID != 0 && pathManager->IsPathValid(unit->pathID)) {
            float3 nextWaypoint = pathManager->NextWayPoint(/* ... */);
            if (nextWaypoint.distance2D(newGoal) < unit->radius * 4.0f) {
                return false; // 当前路径仍然有效
            }
        }
        
        lastRequestTime = gs->frameNum;
        return true;
    }
};
```

### 6.2 路径复用

```cpp
// 实现路径共享以减少计算开销
class PathSharingManager {
    struct SharedPathInfo {
        unsigned int pathID;
        float3 startPos, goalPos;
        float shareRadius;
        std::vector<CUnit*> users;
    };
    
    std::vector<SharedPathInfo> sharedPaths;
    
public:
    unsigned int FindSharedPath(const CUnit* unit, const float3& goal) {
        for (const auto& sharedPath : sharedPaths) {
            // 检查是否可以复用现有路径
            if (unit->pos.distance2D(sharedPath.startPos) < sharedPath.shareRadius &&
                goal.distance2D(sharedPath.goalPos) < sharedPath.shareRadius) {
                
                // 复用路径
                return sharedPath.pathID;
            }
        }
        
        return 0; // 没有找到可复用的路径
    }
    
    void RegisterSharedPath(unsigned int pathID, const CUnit* unit, const float3& goal) {
        SharedPathInfo info;
        info.pathID = pathID;
        info.startPos = unit->pos;
        info.goalPos = goal;
        info.shareRadius = unit->radius * 8.0f; // 共享半径
        info.users.push_back(const_cast<CUnit*>(unit));
        
        sharedPaths.push_back(info);
    }
};
```

### 6.3 自适应配置

```cpp
// 根据游戏状态动态调整配置
class AdaptivePathfindingConfig {
public:
    void UpdateConfig() {
        const int activeUnits = unitHandler->GetActiveUnits().size();
        const float avgFrameTime = GetAverageFrameTime();
        
        // 根据单位数量调整
        if (activeUnits > 1000) {
            // 大量单位：优先性能
            PathConstants::MAX_SEARCHED_NODES = 32768;
            pathManager->SetCacheAggressiveness(HIGH);
            pathManager->SetPathSharingEnabled(true);
            
        } else if (activeUnits < 100) {
            // 少量单位：优先质量
            PathConstants::MAX_SEARCHED_NODES = 131072;
            pathManager->SetCacheAggressiveness(LOW);
            pathManager->SetPathSmoothingLevel(HIGH);
        }
        
        // 根据帧率调整
        if (avgFrameTime > 20.0f) { // 低于50FPS
            // 降低路径搜索开销
            PathConstants::SQUARES_TO_UPDATE /= 2;
            pathManager->EnableLowLatencyMode(true);
            
        } else if (avgFrameTime < 10.0f) { // 高于100FPS
            // 可以提高路径质量
            PathConstants::SQUARES_TO_UPDATE *= 1.5f;
            pathManager->EnableHighQualityMode(true);
        }
    }
};
```

### 6.4 错误处理

```cpp
// 健壮的错误处理机制
void HandlePathfindingError(const CUnit* unit, IPath::SearchResult result) {
    switch (result) {
        case IPath::Error:
            // 致命错误：尝试备选策略
            TryFallbackPathfinding(unit);
            break;
            
        case IPath::GoalOutOfRange:
            // 目标不可达：寻找最接近的可达点
            FindNearestReachableGoal(unit);
            break;
            
        case IPath::CrappyPath:
            // 路径质量差：接受但标记为临时
            AcceptTemporaryPath(unit);
            SchedulePathImprovement(unit);
            break;
            
        default:
            // 未知错误：记录并继续
            LOG_L(L_ERROR, "Unknown pathfinding result: %d", result);
            break;
    }
}
```

通过遵循这些最佳实践，开发者可以充分发挥HAPFS系统的能力，在保证性能的同时获得高质量的路径规划效果。